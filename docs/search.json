[
  {
    "objectID": "pages/projects/headphone_joint.html",
    "href": "pages/projects/headphone_joint.html",
    "title": "Headphone Joint Upgrade",
    "section": "",
    "text": "Hifiman headphones have a reputation for delivering high audio quality at a discount price, but unfortunately, sometimes with discount build quality as well. Both joints attaching the driver to the headband failed on my pair of HE-400s just weeks after purchase, and this Head-Fi forum thread shows that these quality control issues are not uncommon across the early 2010s HIFIMAN headphone lineup.\n\n\n\nBroken headphone joint from the same Head-Fi forum thread)\n\n\nI decided to fix my broken headphones by designing a new enclosure that reinforces the preexisting hardware, and even after years of abuse, the joints have held together strong!\n\n\n\nFinal Headphone Joint Splint"
  },
  {
    "objectID": "pages/projects/headphone_joint.html#overview",
    "href": "pages/projects/headphone_joint.html#overview",
    "title": "Headphone Joint Upgrade",
    "section": "",
    "text": "Hifiman headphones have a reputation for delivering high audio quality at a discount price, but unfortunately, sometimes with discount build quality as well. Both joints attaching the driver to the headband failed on my pair of HE-400s just weeks after purchase, and this Head-Fi forum thread shows that these quality control issues are not uncommon across the early 2010s HIFIMAN headphone lineup.\n\n\n\nBroken headphone joint from the same Head-Fi forum thread)\n\n\nI decided to fix my broken headphones by designing a new enclosure that reinforces the preexisting hardware, and even after years of abuse, the joints have held together strong!\n\n\n\nFinal Headphone Joint Splint"
  },
  {
    "objectID": "pages/projects/headphone_joint.html#files",
    "href": "pages/projects/headphone_joint.html#files",
    "title": "Headphone Joint Upgrade",
    "section": "Files",
    "text": "Files\nI’ve attached the STL which can be printed as-is. Also attached is the Solidworks Model Part, so feel free to modify as you like!\nDownload jointfix_final.STL\nDownload jointfix_final.SLDPRT"
  },
  {
    "objectID": "pages/projects/headphone_joint.html#previous-iterations",
    "href": "pages/projects/headphone_joint.html#previous-iterations",
    "title": "Headphone Joint Upgrade",
    "section": "Previous Iterations",
    "text": "Previous Iterations\n\nTape Fix\nI first tried using tape to hold the broken joint together, but it quickly became clear that it wasn’t going to work. Beyond the ✨aesthetics✨, the adhesive would weaken over time and the tape would begin to slide, eventually leaving the joint loosening. More importantly, the tape failed to address the underlying load path: instead of distributing the clamping force across the ear pads as intended, the headband concentrated that force into a small area at the end of the broken joint.\n\n\n\nTemporary Tape Fix\n\n\nI then attempted to repair the joint using epoxy. This approach introduced its own challenges, particularly keeping the epoxy from intruding into and damaging the sliding joint mechanism. The geometry of the failure also worked against this solution. The joint had sheared along a very small surface area, creating a localized high-stress region. Any small imperfections in the cured epoxy likely acted as stress concentrators, allowing cracks to slowly propagate until the joint failed again.\nAt that point, it became clear that simply restoring the original joint geometry was not sufficient. Rather than trying to recreate the failed interface, I shifted focus toward augmenting the joint by adding new structure carry the load more effectively in the form of a splint.\n\n\nProof of Concept\nMy initial concerns was function and sizing. Tolerancing had to be tight to prevent pieces from wiggling, and the splint had to be rigid enough to hold the parts together. Ergonomically, most of the pressure was along the top of the headband and earpads, but I also wanted to evaluate if adding thickness to then joint would impact comfort.\n\n\n\nVersion 1 and Tape Side by Side\n\n\n\n    \n\n\n\nPackaging\nThe initial splint held the two pieces tight and comfortably, but rocked back and forth. I modified its shape to conform better with the existing circular joint, and to make the overall splint smaller in size and more discrete.\n\n\n\nVersion 3\n\n\n\n    \n\n\n\nStrength and Finishing Features\nI noticed flexing in the joint/splint when I would stretch the drivers apart from eachother. Increasing the wall thickness and the radius of fillet reduced stress and increased rigidity drastically. Additional fillets and finishing touches were added to make the overall design more refined."
  },
  {
    "objectID": "pages/about.html",
    "href": "pages/about.html",
    "title": "Austin Lin",
    "section": "",
    "text": "University of Maryland, College Park | 2020 - 2024\nB.S. Mechanical Engineering\nMinor in Robotics and Autonomous Systems\nPublic Leadership Scholars Program"
  },
  {
    "objectID": "pages/about.html#education",
    "href": "pages/about.html#education",
    "title": "Austin Lin",
    "section": "",
    "text": "University of Maryland, College Park | 2020 - 2024\nB.S. Mechanical Engineering\nMinor in Robotics and Autonomous Systems\nPublic Leadership Scholars Program"
  },
  {
    "objectID": "pages/about.html#experience",
    "href": "pages/about.html#experience",
    "title": "Austin Lin",
    "section": "Experience",
    "text": "Experience\nGeneral Dynamics Electric Boat | Systems Engineer\nSeptember 2024 - Present\nL3Harris C5 | Systems Engineering Intern\nJune 2023 - August 2023\nUMD Space Systems Laboratory | Undergraduate Researcher\nMay 2022 - September 2022\n\n\nThis website was built with Quarto, and hosted on Github Pages."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi!",
    "section": "",
    "text": "Below are some of my favorite projects that I’d to share. Stay tuned for more to come!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHeadphone Joint Upgrade\n\n\nPermanently fixing a common issue with early HIFIMAN Headphones.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLuenberger Observer for Battery Charge Estimation\n\n\nSimulating a Battery and evaluating estimation accuracy under various parameters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWake & Manipulate: Robot Arm\n\n\nRapid prototyping of a robotic arm, controller, and graphical user interface.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "pages/projects/robot_arm.html",
    "href": "pages/projects/robot_arm.html",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "",
    "text": "The goal of this project is to demonstrate rapid prototyping of a small-scale robotic arm that can be controlled intuitively. The system automatically activates when a user is detected via an ultrasonic sensor and powers down when no user is present for convenience. An onboard OLED display provides real-time indication of whether the robot is active or inactive.\nDuring operation, the user can choose to control either the pitch motor or second yaw motor by pressing into the stick. A companion Processing-based visualization lists joint angles and the calculated end-effector position, allowing the user to monitor the robot’s configuration in real time."
  },
  {
    "objectID": "pages/projects/robot_arm.html#overview",
    "href": "pages/projects/robot_arm.html#overview",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "",
    "text": "The goal of this project is to demonstrate rapid prototyping of a small-scale robotic arm that can be controlled intuitively. The system automatically activates when a user is detected via an ultrasonic sensor and powers down when no user is present for convenience. An onboard OLED display provides real-time indication of whether the robot is active or inactive.\nDuring operation, the user can choose to control either the pitch motor or second yaw motor by pressing into the stick. A companion Processing-based visualization lists joint angles and the calculated end-effector position, allowing the user to monitor the robot’s configuration in real time."
  },
  {
    "objectID": "pages/projects/robot_arm.html#architecture",
    "href": "pages/projects/robot_arm.html#architecture",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "Architecture",
    "text": "Architecture\n\nRobot Arm: 3D-printed arm with multiple degrees of freedom. I initially tried to make the robot purely out of cardboard since this was the most widely available material I had the time, but later incorporated pencils to add more strength and rigidity to the structure. The robot arm has two yaw servo motors and a pitch servo motor, and connects directly to the controller. The next iteration would be to 3D print a enclosure for the electronics and the arm.\nController: The controller features an ultrasonic sensor, OLED display and a joystick. The breadboard is used to connect the arm, controller, and arduino together. A 6V battery pack is used as the power supply for the motors and arduino. Future improvements to the controller include designing a custom PCB and controller enclosure for much better packaging, as well as incorporating a physical switch to turn on/off the entire system, and relays to disconnect the motors from the power supply when the arm is turned off automatically.\nSoftware: The system software is divided between an Arduino-based controller and a Processing-based visualization that communicate over a serial connection. The Arduino handles sensing, control logic, and actuator commands, including user detection via an ultrasonic sensor and real-time joint control using a joystick with selectable control modes. An onboard OLED display provides immediate feedback on the system’s active state.\n\nJoint angles are transmitted to the host computer, where the Processing application parses the data, performs forward kinematics calculations, and renders a real-time visualization of joint angles and end-effector position. This separation allows reliable embedded control while providing clear, interactive feedback through the GUI."
  },
  {
    "objectID": "pages/projects/robot_arm.html#demo",
    "href": "pages/projects/robot_arm.html#demo",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "Demo",
    "text": "Demo"
  },
  {
    "objectID": "pages/projects/robot_arm.html#graphics-code",
    "href": "pages/projects/robot_arm.html#graphics-code",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "Graphics Code",
    "text": "Graphics Code\n\nInitialization and Setup\nThe environment is set up by defining basic arm parameters and opening a serial connection to the microcontroller. The serial buffer is cleared to ensure only valid runtime data is processed.\n\n\nShow code\n\nimport processing.serial.*; // add the serial library\nSerial myPort; // define a serial port object to monitor\nfloat armLength = 140; //length of arm in millimeters\nfloat[] armOrigin = {0, 0};\nfinal int armWidth = 10;\nfinal int windowWidth = 1000;\nfinal int windowLength = 1000;\n\nvoid setup() {\n\n  size(1000, 1300); // set the window size\n  println(Serial.list()); // list all available serial ports\n  myPort = new Serial(this, Serial.list()[1], 9600); // define input port\n  myPort.clear(); // clear the port of any initial junk\n  background(255);\n}\n\n\n\ndraw()\nThe draw() function handles real-time visualization of the robot arm by receiving joint angle data from the Arduino over serial communication. There are 3 main components:\n\nSerial Communication: The function first checks if data is available on the serial port, then reads a tab-delimited string containing three joint angles (theta1, pitch, theta2) and converts them from degrees to radians.\nForward Kinematics: Using the received angles and the predefined arm length, the function calculates the 2D positions of key points on the robot arm:\n\nProjects the arm length onto the 2D plane using the pitch angle\nComputes x and y coordinates for the midpoint of the first link, the midpoint of the second link, and the end-effector position\nUses trigonometric calculations based on the joint angles to determine each position relative to the origin\n\nArm Projection: This code projects the arm in 2D space. The code centers the arm on the screen and then draws the base joint. Then for each link, the coordinate frame is moved and rotated to draw the rectangles correctly. pushMatrix() and popMatrix() isolate transformations for each segment.\n\n\n\nShow code\n\nvoid draw () {\n\n  if (myPort.available () &lt;= 0) { //makes sure port is open\n    return;\n  }\n\n  //input processing\n  String inString = myPort.readStringUntil('\\n'); // read input string\n  if (inString != null) { // ignore null strings\n    background(255);\n    textSize(40);\n     text(\"Top View: \", 70, 70);\n    inString = trim(inString); // trim off any whitespace\n    String[] anglesInput = splitTokens(inString, \"\\t\"); // extract x & y into an array\n\n    float theta1 =  float(anglesInput[0]) * PI/180; //conversion to radians\n    float pitch =  float(anglesInput[1]) * PI/180;\n    float theta2 =  float(anglesInput[2]) * PI/180;\n\n    //math to find link/manipulator positions using angles and given lengths relative to an origin\n    //unit vector directions same as window\n    int length2d = int(armLength * cos(pitch));\n    int link1_x = int(length2d * cos(theta1) / 2);\n    int link2_x = link1_x*2 + int(length2d * cos(theta1 + theta2)/2);\n    int end_x = link1_x*2 + int(length2d * cos(theta1 + theta2));\n    int link1_y = int(length2d * sin(theta1) / 2);\n    int link2_y = link1_y*2 + int(length2d * sin(theta1 + theta2)/2);\n    int end_y = link1_y*2 + int( length2d * sin(theta1 + theta2));\n\n    //display angles\n    fill(0, 0, 0);    \n    \n    text(\"Yaw 1:\", 20, 930);\n    text(theta1*180/PI + \"°\", 140, 930);\n    fill(128,128,0);\n    \n    text(\"Yaw 2:\", 320, 930);\n    text(theta2*180/PI + \"°\", 440, 930);\n    fill(0,0,0);\n    \n    text(\"Pitch :\", 620, 930);\n    text(pitch*180/PI + \"°\", 740, 930);\n    \n    fill(0,128,128);\n    text(\"X:\", 20, 970);\n    text(\"Y:\", 320, 970);\n    text(end_x, 140, 970);\n    text(end_y, 440, 970);\n    fill(0,0,0);\n\n    //translates/rotates coordinate frame so that arm origin is at the center of the screen\n    pushMatrix();\n    translate(500, 600);\n    ellipse(0,0,10,10);\n    pushMatrix(); //save origin frame\n    \n    //link 1\n    pushMatrix(); //creates copy of origin frame for link 1\n    rectMode(CENTER); //sets coordinate args to center of rectangle\n    translate(link1_x, -link1_y);\n    rotate(-theta1);\n    rect(0, 0, length2d, armWidth);\n    popMatrix();\n\n    //link 2\n    pushMatrix();\n    translate(link2_x, -link2_y);\n    rotate(-1*(theta1 + theta2));\n    fill(128,128,0);\n    rect(0, 0, length2d, armWidth);// draw rectangle\n    popMatrix();\n    //end effector\n    translate(end_x, -end_y);\n      fill(0,128,128);\n    ellipse(0,0,10,10);\n\n    //clear stack\n    popMatrix();\n    popMatrix();\n    fill(0,0,0);\n\n  }\n}"
  },
  {
    "objectID": "pages/projects/robot_arm.html#controller-code",
    "href": "pages/projects/robot_arm.html#controller-code",
    "title": "Wake & Manipulate: Robot Arm",
    "section": "Controller Code",
    "text": "Controller Code\n\nInitialization and Setup\nPins used for the motor and controller are defined on the arduino. Joystick deadzone and debounce, and ultrasonic sensing distance are also defined. The “on” and “off” image are also defined for the OLED display as a bitmap array.\n\n\nShow code\n\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;Adafruit_SSD1306.h&gt;\n \n//oled reset\n#define OLED_RESET 4\n \n//servo pins\n#define yaw1 10\n#define pitch 11\n#define yaw2 12\n \n//sensor pins\n#define triggerPin 7\n#define echoPin 6\n#define xPin 1\n#define yPin A0\n#define switchPin 2\n#define motorSpeed 2\n \n//deadzone and debounce for joystick\n#define tolerance 200\n#define debounce 150\n \nAdafruit_SSD1306 display(128, 64, &Wire, OLED_RESET);\n \nint startTime, currentTime;  // for timing loop\nlong duration;\nint distance;\n//angles range from 0 - 180\nfloat theta1 = 0;\nfloat theta2 = 0;\nfloat theta3 = 0;\nString dispImg = \"\";\nbool pitchMode = false;\n\n\n\nShow OLED Bitmap\n\n//bitmaps generated from https://diyusthad.com/image2cpp\n// 'OFF, 128x64px\nconst unsigned char offImg[] PROGMEM = {\n \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,\n  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x0e,\n  0x70, 0x00, 0x01, 0xff, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xe0, 0x00, 0x0e,\n  0x70, 0x00, 0x03, 0xff, 0x01, 0xff, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x03, 0xfc, 0x00, 0x7f, 0x80, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x07, 0xf8, 0x00, 0x3f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x07, 0xf0, 0x00, 0x1f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x1f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7f, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xe0, 0x7f, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xe0, 0x7f, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xe0, 0x7f, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xc0, 0x00, 0x0f, 0xe0, 0x7f, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0xe0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x0f, 0xf0, 0x00, 0x1f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x07, 0xf0, 0x00, 0x1f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x07, 0xf8, 0x00, 0x3f, 0xc0, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x03, 0xfc, 0x00, 0x7f, 0x80, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x03, 0xff, 0x03, 0xff, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x01, 0xff, 0xff, 0xfe, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,\n  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n \n};\n\n// 'ON', 128x64px\nconst unsigned char onImg[] PROGMEM = {\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff,\n  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xe0, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x01, 0xff, 0xc0, 0x7f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xc0, 0x7f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xc0, 0x3f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xc0, 0x1f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xf0, 0x07, 0xe0, 0x1f, 0xc0, 0x1f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xf0, 0x0f, 0xc0, 0x0f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xf8, 0x0f, 0xc0, 0x0f, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xe0, 0x7f, 0xfc, 0x07, 0xc0, 0x07, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0x7f, 0xfe, 0x07, 0xc0, 0x03, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xfe, 0x07, 0xc0, 0x03, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xfe, 0x07, 0xc0, 0x01, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xc0, 0x81, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xc0, 0xc0, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xc0, 0xc0, 0x70, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xc0, 0xe0, 0x70, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xc0, 0xe0, 0x30, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xfe, 0x03, 0xc0, 0xf0, 0x10, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xfe, 0x07, 0xc0, 0xf8, 0x10, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0xff, 0xfe, 0x07, 0xc0, 0xf8, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xc0, 0x7f, 0xfe, 0x07, 0xc0, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xe0, 0x7f, 0xfc, 0x07, 0xc0, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xf8, 0x0f, 0xc0, 0xfe, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xf0, 0x0f, 0xc0, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xf0, 0x07, 0xe0, 0x1f, 0xc0, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xc0, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xc0, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xc0, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0x80, 0x01, 0xff, 0xc0, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xe0, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n  0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n};\n\n\n\nShow code\n\nvoid setup() {\n  //setup timing loop, serial, and pin\n  startTime = millis();\n \n  pinMode(yaw1, OUTPUT);  //setup digital pin\n  pinMode(yaw2, OUTPUT);\n  pinMode(pitch, OUTPUT);\n  pinMode(switchPin, INPUT_PULLUP);\n  pinMode(triggerPin, OUTPUT);  // Sets the trigPin as an Output\n  pinMode(echoPin, INPUT);      // Sets the echoPin as an Input\n  clearDisplay();\n  Serial.begin(9600);\n \n \n  //resets servos to initial position\n  servoControl(0, pitch);\n  servoControl(0, yaw1);\n  servoControl(0, yaw2);\n}\n\n\n\nMain Loop\nThe microcontroller performs 4 main actions in the loop:\n\nAutomatic Activation: The ultrasonic sensor checks if a user is within 60cm. If no user is detected, the system displays “OFF” on the OLED and exits the loop with no motor commands sent, effectively deactivating motor control. When a user approaches, it displays “ON” and proceeds with normal operation.\nJoystick Control: The joystick’s X-axis always controls the first yaw joint (theta1). The Y-axis control is mode-dependent: in pitch mode, it controls the vertical pitch joint (theta2); otherwise, it controls the second yaw joint (theta3). All joint movements are constrained within 0-180 degrees due to the servo hardware.\nMode Switching: Pressing the joystick button toggles between pitch and yaw control modes for the Y-axis.\nData Transmission: At the end of each loop cycle, all three joint angles are sent via serial communication to the Processing visualization as tab-separated values.\n\n\n\nShow code\n\nvoid loop() {\n \n  //ultrasonic activation\n  if (ultraSonic() &gt; 60) {\n \n    //clears oled display if needed\n    if (dispImg == \"on\") {\n      clearDisplay();\n    }\n    dispImg = \"off\";\n    drawOff();\n    return;\n  } else {\n    //clears oled display if needed\n    if (dispImg == \"off\") {\n      clearDisplay();\n    }\n    drawOn();\n    dispImg = \"on\";\n  }\n \n  //joystick inputs update theta\n  int dX = readX();\n \n  if (dX + theta1 &lt;= 180 && dX + theta1 &gt;= 0) {  //range bounds\n    theta1 += dX;\n    servoControl(theta1, yaw1);\n  }\n  int dY = readY();\n  if (dY + theta2 &lt;= 180 && dY + theta2 &gt;= 0 && pitchMode) {  //range bounds\n    theta2 += dY;\n    servoControl(theta2, pitch);\n  }\n  if (dY + theta3 &lt;= 180 && dY + theta3 &gt;= 0 && !pitchMode) {  //range bounds\n    theta3 += dY;\n    servoControl(theta3, yaw2);\n  }\n\n  //toggle between modes\n  if (analogRead(switchPin) &lt;= 5) {\n    pitchMode = !pitchMode;\n    delay(debounce);  //debounce\n  }\n \n \n  //angles for processing\n  Serial.println(String(theta1) + \"\\t\" + String(theta2) + \"\\t\" + String(theta3));\n}\n\n\n\nHelper Functions\n\nJoystick Reading (readAxis, readX, readY): Reads analog joystick input and converts it into directional commands. The function implements a deadzone (tolerance of 200 around the center value of 507) to ignore small unintentional movements, returning the motor speed multiplied by direction (-1 for left/down, 0 for center, +1 for right/up).\nServo Control (pwmPulse, servoControl): Generates PWM signals to control the servos without using a servo library. The servoControl function maps desired angles (0-330°) to pulse widths (550-2450 microseconds) and ensures a 20ms period between pulses, which is the standard servo control frequency.\nUltrasonic Sensing (ultraSonic): Measures distance using an ultrasonic sensor by sending a trigger pulse, measuring the echo return time, and converting it to distance in centimeters using the speed of sound at sea level (0.034 cm/microsecond divided by 2 for round-trip).\nDisplay Functions (drawOn, drawOff, clearDisplay): Render the predefined “ON” and “OFF” bitmaps to the OLED display and handle display initialization and clearing.\n\n\n\nShow code\n\nint readAxis(int pin) {  //returns 1 if right, zero if centered, -1 if left\n  int reading = analogRead(pin);\n  if (reading &lt; 507 - tolerance) {\n    return -1 * motorSpeed;\n  }\n  if (reading &gt; 507 + tolerance) {\n    return motorSpeed;\n  }\n  return 0;\n}\n \nint readX() {\n  return readAxis(xPin);\n}\nint readY() {\n  return readAxis(yPin);\n}\n \n//PWM pulse\nvoid pwmPulse(int period, int pin) {\n  digitalWrite(pin, LOW);\n  delayMicroseconds(10);\n  digitalWrite(pin, HIGH);    // turn the LED on (HIGH is the voltage level)\n  delayMicroseconds(period);  // wait for delayLength\n  digitalWrite(pin, LOW);     // turn the LED off by making the voltage LOW\n}\n \n//input- servo angle\nvoid servoControl(float angle, int pin) {\n  int tControl = map(angle, 0, 330, 550, 2450);\n \n  //timing loop for PWM 20ms period\n  currentTime = millis();\n  if ((currentTime - startTime) &gt;= 20) {\n    pwmPulse(tControl, pin);  //pulse\n    startTime = currentTime;\n  }\n  delay(20);\n}\n \nint ultraSonic() {\n  // reset trigger\n  pwmPulse(10, triggerPin);\n  duration = pulseIn(echoPin, HIGH);  //listening for echo\n  distance = duration * 0.034 / 2;    // distance conversion\n  return distance;\n}\n \n//draws \"on\" on oled display\nvoid drawOn() {\n  display.drawBitmap(0, 0, onImg, 128, 64, WHITE);  // display.drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)\n  display.display();\n}\n \nvoid drawOff() {\n  display.drawBitmap(0, 0, offImg, 128, 64, WHITE);  // display.drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)\n  display.display();\n}\n \nvoid clearDisplay() {\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n  display.clearDisplay();\n}"
  },
  {
    "objectID": "pages/projects/battery_estimator.html",
    "href": "pages/projects/battery_estimator.html",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "",
    "text": "This project explores State of Charge (SOC) estimation for a lithium-ion battery using a simple electrical model and a Luenberger-style observer. The goal was to understand how noisy current and voltage measurements impact SOC estimation, and how feedback can be used to guarantee convergence.\nThe model and estimator were implemented in MATLAB, with injected measurement noise to simulate real-world sensor behavior."
  },
  {
    "objectID": "pages/projects/battery_estimator.html#overview",
    "href": "pages/projects/battery_estimator.html#overview",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "",
    "text": "This project explores State of Charge (SOC) estimation for a lithium-ion battery using a simple electrical model and a Luenberger-style observer. The goal was to understand how noisy current and voltage measurements impact SOC estimation, and how feedback can be used to guarantee convergence.\nThe model and estimator were implemented in MATLAB, with injected measurement noise to simulate real-world sensor behavior."
  },
  {
    "objectID": "pages/projects/battery_estimator.html#battery-model",
    "href": "pages/projects/battery_estimator.html#battery-model",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Battery Model",
    "text": "Battery Model\nFor our battery model, we chose to model the battery with a RC pair of 0.05 ohm and a 7920 coulomb. This is typical for a 2200 mAh battery, which usually operates at about 3.6v for lithium chemistries[1][2]. We set the initial estimate of the model to be at 50% SOC. The function for the true and estimated voltage are the same, albeit with the true and estimated SOC variables, respectively. We also set a gaussian distribution for voltage and current reading noise, of 100mV and 10 mA, respectively.\nOur battery model has a step size of 0.1 seconds over 2700 seconds. For the true model, the SOC charge/discharge rate is calculated based on the input current and the charge capacity of the battery. The true rate is then added or subtracted to the actual SOC. The SOC state evolves according to: \\[\n\\dot{SOC} = \\frac{I}{Q}\n\\]\nwhere: \\(I\\) is the input current \\(Q\\) is the battery capacity in coulombs"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#observer-design",
    "href": "pages/projects/battery_estimator.html#observer-design",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Observer Design",
    "text": "Observer Design\nThe estimator mirrors the true SOC dynamics. However, we also introduce current noise to the input current to simulate an ammeter reading the current going into the battery. We also introduce feedback. This is done by taking the voltage reading of the battery (again, with measurement noise), and subtracting this with the voltage estimate. The Luenberger gain scales the ‘strength’ of the error between the model and estimate.\nThe observer update law is:\n\\[\n\\dot{\\hat{SOC}} = \\frac{I + n_I}{Q} + K (V_{meas} - \\hat{V})\n\\]\nWhere: \\(K\\) is the observer (Luenberger) gain\nIt is important to note that the Luenberger observer will only work if the real plant is observable; the slope of the OCV-SOC curve must be nonzero. This method guarantees convergence and speed."
  },
  {
    "objectID": "pages/projects/battery_estimator.html#matlab-implementation",
    "href": "pages/projects/battery_estimator.html#matlab-implementation",
    "title": "Battery SOC Modeling and Estimation",
    "section": "MATLAB Implementation",
    "text": "MATLAB Implementation\n\n\nShow code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nQ = 7920          # C\nRs = 0.05         # Ohm\nkalmanGain = 0.0022\ninputCurrent = -2.200  # A\n\n# Initial states\nsocTrue = [0.90]\nsocEstimate = [0.50]\n\nvoltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]\nvoltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]\n\ncurrentNoise = 0.01  # standard deviation of current noise\nvoltageNoise = 0.1   # standard deviation of voltage noise\n\ntimeStep = 0.1\ntimeEnd = 60*60*0.75\nt = np.arange(0, timeEnd + timeStep, timeStep)\n\n# Simulation loop\nfor i in range(1, len(t)):\n    # True SOC update\n    socDot = (1/Q) * inputCurrent\n    socTrue.append(socTrue[i-1] + socDot*timeStep)\n    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)\n\n    # Estimated SOC update\n    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())\n                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()\n                                    - voltageEstimate[i-1]))\n    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)\n    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))\n\n# Convert to numpy arrays for plotting\nsocTrue = np.array(socTrue)\nsocEstimate = np.array(socEstimate)\nvoltageTrue = np.array(voltageTrue)\nvoltageEstimate = np.array(voltageEstimate)\n\n# Plot SOC\nplt.figure(figsize=(10,4))\nplt.plot(t, socTrue, label='True SOC', linewidth=2)\nplt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('SOC')\nplt.title('SOC Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n# Plot Voltage\nplt.figure(figsize=(10,4))\nplt.plot(t, voltageTrue, label='True Voltage', linewidth=2)\nplt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.title('Voltage Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#results",
    "href": "pages/projects/battery_estimator.html#results",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "Results",
    "text": "Results\n\nConstant 2.2A Discharge, 90% initial SOC\n\n\nShow code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nQ = 7920          # C\nRs = 0.05         # Ohm\nkalmanGain = 0.0022\ninputCurrent = -2.200  # A\n\n# Initial states\nsocTrue = [0.90]\nsocEstimate = [0.50]\n\nvoltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]\nvoltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]\n\ncurrentNoise = 0.01  # standard deviation of current noise\nvoltageNoise = 0.1   # standard deviation of voltage noise\n\ntimeStep = 0.1\ntimeEnd = 60*60*0.75\nt = np.arange(0, timeEnd + timeStep, timeStep)\n\n# Simulation loop\nfor i in range(1, len(t)):\n    # True SOC update\n    socDot = (1/Q) * inputCurrent\n    socTrue.append(socTrue[i-1] + socDot*timeStep)\n    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)\n\n    # Estimated SOC update\n    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())\n                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()\n                                    - voltageEstimate[i-1]))\n    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)\n    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))\n\n# Convert to numpy arrays for plotting\nsocTrue = np.array(socTrue)\nsocEstimate = np.array(socEstimate)\nvoltageTrue = np.array(voltageTrue)\nvoltageEstimate = np.array(voltageEstimate)\n\n# Plot SOC\nplt.figure(figsize=(10,4))\nplt.plot(t, socTrue, label='True SOC', linewidth=2)\nplt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('SOC')\nplt.title('SOC Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n# Plot Voltage\nplt.figure(figsize=(10,4))\nplt.plot(t, voltageTrue, label='True Voltage', linewidth=2)\nplt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.title('Voltage Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstant 2.2A Charge, 0% initial SOC\n\n\nShow code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nQ = 7920          # C\nRs = 0.05         # Ohm\nkalmanGain = 0.0022\ninputCurrent = 2.200  # A\n\n# Initial states\nsocTrue = [0.00]\nsocEstimate = [0.50]\n\nvoltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]\nvoltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]\n\ncurrentNoise = 0.01  # standard deviation of current noise\nvoltageNoise = 0.1   # standard deviation of voltage noise\n\ntimeStep = 0.1\ntimeEnd = 60*60*0.75\nt = np.arange(0, timeEnd + timeStep, timeStep)\n\n# Simulation loop\nfor i in range(1, len(t)):\n    # True SOC update\n    socDot = (1/Q) * inputCurrent\n    socTrue.append(socTrue[i-1] + socDot*timeStep)\n    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)\n\n    # Estimated SOC update\n    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())\n                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()\n                                    - voltageEstimate[i-1]))\n    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)\n    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))\n\n# Convert to numpy arrays for plotting\nsocTrue = np.array(socTrue)\nsocEstimate = np.array(socEstimate)\nvoltageTrue = np.array(voltageTrue)\nvoltageEstimate = np.array(voltageEstimate)\n\n# Plot SOC\nplt.figure(figsize=(10,4))\nplt.plot(t, socTrue, label='True SOC', linewidth=2)\nplt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('SOC')\nplt.title('SOC Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n# Plot Voltage\nplt.figure(figsize=(10,4))\nplt.plot(t, voltageTrue, label='True Voltage', linewidth=2)\nplt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.title('Voltage Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDespite noisy measurements, the SOC estimate converges smoothly to the true SOC. The voltage estimate tracks the real cell voltage closely, demonstrating effective observer feedback.\n\n\nConstant 0.5A Discharge, 90% initial SOC\n\n\nShow code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nQ = 7920          # C\nRs = 0.05         # Ohm\nkalmanGain = 0.0022\ninputCurrent = -2.200  # A\n\n# Initial states\nsocTrue = [0.90]\nsocEstimate = [0.50]\n\nvoltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]\nvoltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]\n\ncurrentNoise = 0.01  # standard deviation of current noise\nvoltageNoise = 0.1   # standard deviation of voltage noise\n\ntimeStep = 0.1\ntimeEnd = 60*60*0.75\nt = np.arange(0, timeEnd + timeStep, timeStep)\n\n# Simulation loop\nfor i in range(1, len(t)):\n    # True SOC update\n    socDot = (1/Q) * inputCurrent\n    socTrue.append(socTrue[i-1] + socDot*timeStep)\n    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)\n\n    # Estimated SOC update\n    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())\n                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()\n                                    - voltageEstimate[i-1]))\n    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)\n    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))\n\n# Convert to numpy arrays for plotting\nsocTrue = np.array(socTrue)\nsocEstimate = np.array(socEstimate)\nvoltageTrue = np.array(voltageTrue)\nvoltageEstimate = np.array(voltageEstimate)\n\n# Plot SOC\nplt.figure(figsize=(10,4))\nplt.plot(t, socTrue, label='True SOC', linewidth=2)\nplt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('SOC')\nplt.title('SOC Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n# Plot Voltage\nplt.figure(figsize=(10,4))\nplt.plot(t, voltageTrue, label='True Voltage', linewidth=2)\nplt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.title('Voltage Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAt 500 seconds for 0.5 Amps discharge, the difference between the estimate and true SOC is about 4.7% percent. At 500 seconds for 2.2 Amps discharge and charge, the difference is about 4.4%. Thus from our model and observer we can conclude that after 500 seconds, the Kalman filter predicts the true SOC within 5% for standard operation, and continues to converge. But before 500 seconds, the error is drastically greater when the initial estimate is set at 50% charge. Depending on the application, it could make sense to adjust the initial estimate closer to 0% charge (to get a more accurate battery reading if it is close to empty)."
  },
  {
    "objectID": "pages/projects/battery_estimator.html#files",
    "href": "pages/projects/battery_estimator.html#files",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Files",
    "text": "Files\n\nDownload MATLAB script"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#key-takeaways",
    "href": "pages/projects/battery_estimator.html#key-takeaways",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nSOC estimation is highly sensitive to voltage modeling accuracy\nObserver feedback dramatically improves robustness\nEven simple linear observers can perform well if the system is observable"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#original-matlab-implementation",
    "href": "pages/projects/battery_estimator.html#original-matlab-implementation",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Original MATLAB Implementation",
    "text": "Original MATLAB Implementation\n\n\nShow code\n\nclc; clf; clear;\n\nQ = 7920; % C\nRs = 0.05; % Ohm\nkalmanGain = 0.0022;\ninputCurrent = -2.200; % A\n\nsocTrue = 0.90;\nsocEstimate = 0.50;\n\nvoltageTrue = 2 + 2*socTrue + Rs*inputCurrent;\nvoltageEstimate = 2 + 2*socEstimate + Rs*inputCurrent;\n\ncurrentNoise = 0.01;\nvoltageNoise = 0.1;\n\ntimeStep = 0.1;\ntimeEnd = 60*60*0.75;\nt = 0:timeStep:timeEnd;\n\nfor i = 2:length(t)\n   socDot = (1/Q)*inputCurrent;\n   socTrue(i) = socTrue(i-1) + socDot*timeStep;\n   voltageTrue(i) = 2 + 2*socTrue(i) + Rs*inputCurrent;\n\n   socEstimateDot = (1/Q)*(inputCurrent + currentNoise*randn()) ...\n      + kalmanGain*(voltageTrue(i-1) + voltageNoise*randn() ...\n      - voltageEstimate(i-1));\n\n   socEstimate(i) = socEstimate(i-1) + socEstimateDot*timeStep;\n   voltageEstimate(i) = 2 + 2*socEstimate(i) ...\n      + Rs*(inputCurrent + currentNoise*randn());\nend"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#python-implementation",
    "href": "pages/projects/battery_estimator.html#python-implementation",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Python Implementation",
    "text": "Python Implementation\n\n\nShow code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nQ = 7920          # C\nRs = 0.05         # Ohm\nkalmanGain = 0.0022\ninputCurrent = -2.200  # A\n\n# Initial states\nsocTrue = [0.90]\nsocEstimate = [0.50]\n\nvoltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]\nvoltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]\n\ncurrentNoise = 0.01  # standard deviation of current noise\nvoltageNoise = 0.1   # standard deviation of voltage noise\n\ntimeStep = 0.1\ntimeEnd = 60*60*0.75\nt = np.arange(0, timeEnd + timeStep, timeStep)\n\n# Simulation loop\nfor i in range(1, len(t)):\n    # True SOC update\n    socDot = (1/Q) * inputCurrent\n    socTrue.append(socTrue[i-1] + socDot*timeStep)\n    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)\n\n    # Estimated SOC update\n    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())\n                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()\n                                    - voltageEstimate[i-1]))\n    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)\n    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))\n\n# Convert to numpy arrays for plotting\nsocTrue = np.array(socTrue)\nsocEstimate = np.array(socEstimate)\nvoltageTrue = np.array(voltageTrue)\nvoltageEstimate = np.array(voltageEstimate)\n\n# Plot SOC\nplt.figure(figsize=(10,4))\nplt.plot(t, socTrue, label='True SOC', linewidth=2)\nplt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('SOC')\nplt.title('SOC Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n# Plot Voltage\nplt.figure(figsize=(10,4))\nplt.plot(t, voltageTrue, label='True Voltage', linewidth=2)\nplt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Voltage (V)')\nplt.title('Voltage Estimator')\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDespite noisy measurements, the SOC estimate converges smoothly to the true SOC. The voltage estimate tracks the real cell voltage closely, demonstrating effective observer feedback."
  },
  {
    "objectID": "pages/projects/battery_estimator.html#references",
    "href": "pages/projects/battery_estimator.html#references",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#footnotes",
    "href": "pages/projects/battery_estimator.html#footnotes",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTenergy 18650 Li-ion Battery↩︎\nAdafruit 18650 Li-ion Battery↩︎"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#project-background",
    "href": "pages/projects/battery_estimator.html#project-background",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "Project Background",
    "text": "Project Background\nThis was originally a group project by me, Alex Miller, and Joseph Kirby for a senior elective (ENME489N battery operation, modeling, and reliability), where we made the Battery and Estimator model in MATLAB with a writeup. Estimating how much charge is left in a battery is an incredibly practical, yet surprisingly challenging problem to solve, which is why I decided to showcase what we did on my website. I’ve expanded on our original work by adapting our model into python, and expanding the background and math discussion.\nOur battery model featured is incredibly simplified since it assumes a linear Open Current Voltage (OCV) vs. State of Charge (SOC) curves. However, in the real world, a wide variety of factors makes the “true” curve non-linear. For instance, different battery chemistries and physical properties have distinctive curves. One challenge with battery estimation is that sometimes the OCV-SOC curve has “plateaus” such that similar OCVs correspond drastically different SOCs, making the SOC effectively unobservable by OCV alone. Additionally, the temperature can drastically reduce the OCV even though the battery has not discharged any energy. Jeff Shepard has a fantastic article with visuals of how these factors impact the OCV-SOC curve.\n\nTrue Battery SOC and Voltage Model\nFor our battery model, we chose to model the battery with a RC pair of 0.05 ohm and a 7920 coulomb. This is typical for a 2200 mAh battery, which usually operates at about 3.6v for lithium chemistries1 2. We set the initial estimate of the model to be at 50% SOC. The function for the true and estimated voltage are the same, albeit with the true and estimated SOC variables, respectively. We also set a gaussian distribution for voltage and current reading noise, of 100mV and 10 mA, respectively. For the true model, the SOC charge/discharge rate is calculated based on the input current and the charge capacity of the battery. The true rate is then added or subtracted to the actual SOC.\nBelow are the state space equations governing the true battery model and the soc estimator. The simulation uses Euler’s method, and their respective equations are also shown. Our battery model has a step size of 0.1 seconds over 2700 seconds.\nContinuous-time:\n\\[\n\\dot{SOC}(t) = \\frac{I(t)}{Q}, \\quad\nV_\\text{true}(t) = 2 + 2 \\, SOC(t) + R_s \\, I(t)\n\\]\nWhere:\n\n\\(SOC(t)\\) : State of Charge at time \\(t\\) (fraction 0–1)\n\n\\(V_\\text{true}(t)\\) : True battery voltage (V)\n\n\\(I(t)\\) : Input current (A)\n\n\\(Q\\) : Battery capacity (Coulombs)\n\n\\(R_s\\) : Battery internal series resistance (Ω)\n\nDiscrete-time (Euler integration):\n\\[\nSOC[k] = SOC[k-1] + \\Delta t \\frac{I[k-1]}{Q}, \\quad\nV_\\text{true}[k] = 2 + 2 \\, SOC[k] + R_s \\, I[k]\n\\]\nWhere:\n\n\\(k\\) : Discrete time step index\n\n\\(\\Delta t\\) : Time step (s)\n\n\n\n\nSOC Estimator (Luenberger Observer)\nFor the estimator, calculating the rate is very similar. However, we also introduce current noise to the input current to simulate an ammeter reading the current going into the battery. We also introduce feedback. This is done by taking the voltage reading of the battery (again, with measurement noise), and subtracting this with the voltage estimate. The Luenberger gain scales the ‘strength’ of the error between the model and estimate. It is important to note that the Luenberger observer will only work if the real plant is observable; the slope of the OCV-SOC curve must be nonzero. This method guarantees convergence and speed, as visible in the following figures:\nContinuous-time:\n\\[\n\\dot{\\hat{SOC}}(t) = \\frac{I(t) + n_I(t)}{Q} + K \\left( V_\\text{true}(t) + n_V(t) - \\hat{V}(t) \\right)\n\\]\n\\[\n\\hat{V}(t) = 2 + 2 \\, \\hat{SOC}(t) + R_s \\left(I(t) + n_I(t)\\right)\n\\]\nWhere:\n\n\\(\\hat{SOC}(t)\\) : Estimated SOC\n\n\\(\\hat{V}(t)\\) : Estimated battery voltage\n\n\\(n_I(t)\\) : Current measurement noise\n\n\\(n_V(t)\\) : Voltage measurement noise\n\n\\(K\\) : Observer (Luenberger) gain\n\nDiscrete-time:\n\\[\n\\hat{SOC}[k] = \\hat{SOC}[k-1] + \\Delta t \\Big[ \\frac{I[k-1] + n_I[k-1]}{Q} + K \\left( V_\\text{true}[k-1] + n_V[k-1] - \\hat{V}[k-1] \\right) \\Big]\n\\]\n\\[\n\\hat{V}[k] = 2 + 2 \\, \\hat{SOC}[k] + R_s \\left(I[k] + n_I[k]\\right)\n\\]\nWhere:\n\n\\(k\\) : Discrete time step index\n\n\\(\\Delta t\\) : Time step (s)\n\nOther variables are same as in continuous-time equations"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#sec-matlab",
    "href": "pages/projects/battery_estimator.html#sec-matlab",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Original Matlab Model",
    "text": "Original Matlab Model\n\n\nShow code\n\n\nclc; clf; clear;\n\nQ = 7920; % C\nRs = 0.05; % Ohm\nkalmanGain = 0.0022;\ninputCurrent = -2.200; % A\n\nsocTrue = 0.90;\nsocEstimate = 0.50;\n\nvoltageTrue = 2 + 2*socTrue + Rs*inputCurrent;\nvoltageEstimate = 2 + 2*socEstimate + Rs*inputCurrent;\n\ncurrentNoise = 0.01;\nvoltageNoise = 0.1;\n\ntimeStep = 0.1;\ntimeEnd = 60*60*0.75;\nt = 0:timeStep:timeEnd;\n\nfor i = 2:length(t)\n   socDot = (1/Q)*inputCurrent;\n   socTrue(i) = socTrue(i-1) + socDot*timeStep;\n   voltageTrue(i) = 2 + 2*socTrue(i) + Rs*inputCurrent;\n\n   socEstimateDot = (1/Q)*(inputCurrent + currentNoise*randn()) ...\n      + kalmanGain*(voltageTrue(i-1) + voltageNoise*randn() ...\n      - voltageEstimate(i-1));\n\n   socEstimate(i) = socEstimate(i-1) + socEstimateDot*timeStep;\n   voltageEstimate(i) = 2 + 2*socEstimate(i) ...\n      + Rs*(inputCurrent + currentNoise*randn());\nend"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#original-matlab-model",
    "href": "pages/projects/battery_estimator.html#original-matlab-model",
    "title": "Luenberger Observer for Battery Charge Estimation",
    "section": "Original Matlab Model",
    "text": "Original Matlab Model\n\n\nShow code\n\n\nclc; clf; clear;\n\nQ = 7920; % C\nRs = 0.05; % Ohm\nkalmanGain = 0.0022;\ninputCurrent = -2.200; % A\n\nsocTrue = 0.90;\nsocEstimate = 0.50;\n\nvoltageTrue = 2 + 2*socTrue + Rs*inputCurrent;\nvoltageEstimate = 2 + 2*socEstimate + Rs*inputCurrent;\n\ncurrentNoise = 0.01;\nvoltageNoise = 0.1;\n\ntimeStep = 0.1;\ntimeEnd = 60*60*0.75;\nt = 0:timeStep:timeEnd;\n\nfor i = 2:length(t)\n   socDot = (1/Q)*inputCurrent;\n   socTrue(i) = socTrue(i-1) + socDot*timeStep;\n   voltageTrue(i) = 2 + 2*socTrue(i) + Rs*inputCurrent;\n\n   socEstimateDot = (1/Q)*(inputCurrent + currentNoise*randn()) ...\n      + kalmanGain*(voltageTrue(i-1) + voltageNoise*randn() ...\n      - voltageEstimate(i-1));\n\n   socEstimate(i) = socEstimate(i-1) + socEstimateDot*timeStep;\n   voltageEstimate(i) = 2 + 2*socEstimate(i) ...\n      + Rs*(inputCurrent + currentNoise*randn());\nend"
  },
  {
    "objectID": "pages/projects/battery_estimator.html#matlab",
    "href": "pages/projects/battery_estimator.html#matlab",
    "title": "Battery SOC Modeling and Estimation",
    "section": "Original Matlab Model",
    "text": "Original Matlab Model\n\n\nShow code\n\n\nclc; clf; clear;\n\nQ = 7920; % C\nRs = 0.05; % Ohm\nkalmanGain = 0.0022;\ninputCurrent = -2.200; % A\n\nsocTrue = 0.90;\nsocEstimate = 0.50;\n\nvoltageTrue = 2 + 2*socTrue + Rs*inputCurrent;\nvoltageEstimate = 2 + 2*socEstimate + Rs*inputCurrent;\n\ncurrentNoise = 0.01;\nvoltageNoise = 0.1;\n\ntimeStep = 0.1;\ntimeEnd = 60*60*0.75;\nt = 0:timeStep:timeEnd;\n\nfor i = 2:length(t)\n   socDot = (1/Q)*inputCurrent;\n   socTrue(i) = socTrue(i-1) + socDot*timeStep;\n   voltageTrue(i) = 2 + 2*socTrue(i) + Rs*inputCurrent;\n\n   socEstimateDot = (1/Q)*(inputCurrent + currentNoise*randn()) ...\n      + kalmanGain*(voltageTrue(i-1) + voltageNoise*randn() ...\n      - voltageEstimate(i-1));\n\n   socEstimate(i) = socEstimate(i-1) + socEstimateDot*timeStep;\n   voltageEstimate(i) = 2 + 2*socEstimate(i) ...\n      + Rs*(inputCurrent + currentNoise*randn());\nend"
  }
]