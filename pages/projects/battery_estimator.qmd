---
title: "Luenberger Observer for Battery Charge Estimation"
description: "Simulating a Battery and evaluating estimation accuracy under various parameters"
image: "../../assets/soc_estimator/soc_estimator.png"
---

## Overview

This project explores **State of Charge (SOC) estimation** for a lithium-ion battery using a simple electrical model and a Luenberger-style observer. The goal was to understand how noisy current and voltage measurements impact SOC estimation, and how feedback can be used to guarantee convergence.

The model and estimator were implemented in **MATLAB**, with injected measurement noise to simulate real-world sensor behavior.

## Project Background

This was originally a group project by me, Alex Miller, and Joseph Kirby for a senior elective (ENME489N battery operation, modeling, and reliability), where we made the Battery and Estimator model in MATLAB with a writeup. Estimating how much charge is left in a battery is an incredibly practical, yet surprisingly challenging problem to solve, which is why I decided to showcase what we did on my website. I've expanded on our original work by adapting our model into python, and expanding the background and math discussion.

Our battery model featured is incredibly simplified since it assumes a linear Open Current Voltage (OCV) vs. State of Charge (SOC) curves. However, in the real world, a wide variety of factors makes the "true" curve non-linear. For instance, different battery chemistries and physical properties have distinctive curves. One challenge with battery estimation is that sometimes the OCV-SOC curve has "plateaus" such that similar OCVs correspond drastically different SOCs, making the SOC effectively unobservable by OCV alone. Additionally, the temperature can drastically reduce the OCV even though the battery has not discharged any energy. Jeff Shepard has a [fantastic article](https://www.batterypowertips.com/how-to-read-battery-discharge-curves-faq/) with visuals of how these factors impact the OCV-SOC curve.

### True Battery SOC and Voltage Model

For our battery model, we chose to model the battery with a RC pair of 0.05 ohm and a 7920 coulomb. This is typical for a 2200 mAh battery, which usually operates at about 3.6v for lithium chemistries[^1] [^2]. We set the initial estimate of the model to be at 50% SOC. The function for the true and estimated voltage are the same, albeit with the true and estimated SOC variables, respectively. We also set a gaussian distribution for voltage and current reading noise, of 100mV and 10 mA, respectively. For the true model, the SOC charge/discharge rate is calculated based on the input current and the charge capacity of the battery. The true rate is then added or subtracted to the actual SOC.

Below are the state space equations governing the true battery model and the soc estimator. The simulation uses Euler's method, and their respective equations are also shown. Our battery model has a step size of 0.1 seconds over 2700 seconds.

**Continuous-time:**

$$
\dot{SOC}(t) = \frac{I(t)}{Q}, \quad
V_\text{true}(t) = 2 + 2 \, SOC(t) + R_s \, I(t)
$$

**Where:**

- $SOC(t)$ : State of Charge at time $t$ (fraction 0–1)  
- $V_\text{true}(t)$ : True battery voltage (V)  
- $I(t)$ : Input current (A)  
- $Q$ : Battery capacity (Coulombs)  
- $R_s$ : Battery internal series resistance (Ω)  

**Discrete-time (Euler integration):**

$$
SOC[k] = SOC[k-1] + \Delta t \frac{I[k-1]}{Q}, \quad
V_\text{true}[k] = 2 + 2 \, SOC[k] + R_s \, I[k]
$$

**Where:**

- $k$ : Discrete time step index  
- $\Delta t$ : Time step (s)  

---

### SOC Estimator (Luenberger Observer)

For the estimator, calculating the rate is very similar. However, we also introduce current noise to the input current to simulate an ammeter reading the current going into the battery. We also introduce feedback. This is done by taking the voltage reading of the battery (again, with measurement noise), and subtracting this with the voltage estimate. The Luenberger gain scales the ‘strength’ of the error between the model and estimate. It is important to note that the Luenberger observer will only work if the real plant is observable; the slope of the OCV-SOC curve must be nonzero. This method guarantees convergence and speed, as visible in the following figures:

**Continuous-time:**

$$
\dot{\hat{SOC}}(t) = \frac{I(t) + n_I(t)}{Q} + K \left( V_\text{true}(t) + n_V(t) - \hat{V}(t) \right)
$$

$$
\hat{V}(t) = 2 + 2 \, \hat{SOC}(t) + R_s \left(I(t) + n_I(t)\right)
$$

**Where:**

- $\hat{SOC}(t)$ : Estimated SOC  
- $\hat{V}(t)$ : Estimated battery voltage  
- $n_I(t)$ : Current measurement noise  
- $n_V(t)$ : Voltage measurement noise  
- $K$ : Observer (Luenberger) gain  

**Discrete-time:**

$$
\hat{SOC}[k] = \hat{SOC}[k-1] + \Delta t \Big[ \frac{I[k-1] + n_I[k-1]}{Q} + K \left( V_\text{true}[k-1] + n_V[k-1] - \hat{V}[k-1] \right) \Big]
$$

$$
\hat{V}[k] = 2 + 2 \, \hat{SOC}[k] + R_s \left(I[k] + n_I[k]\right)
$$

**Where:**

- $k$ : Discrete time step index  
- $\Delta t$ : Time step (s)  
- Other variables are same as in continuous-time equations

## Results

### Constant 2.2A Discharge, 90% initial SOC
```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Q = 7920          # C
Rs = 0.05         # Ohm
kalmanGain = 0.0022
inputCurrent = -2.200  # A

# Initial states
socTrue = [0.90]
socEstimate = [0.50]

voltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]
voltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]

currentNoise = 0.01  # standard deviation of current noise
voltageNoise = 0.1   # standard deviation of voltage noise

timeStep = 0.1
timeEnd = 60*60*0.75
t = np.arange(0, timeEnd + timeStep, timeStep)

# Simulation loop
for i in range(1, len(t)):
    # True SOC update
    socDot = (1/Q) * inputCurrent
    socTrue.append(socTrue[i-1] + socDot*timeStep)
    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)

    # Estimated SOC update
    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())
                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()
                                    - voltageEstimate[i-1]))
    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)
    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))

# Convert to numpy arrays for plotting
socTrue = np.array(socTrue)
socEstimate = np.array(socEstimate)
voltageTrue = np.array(voltageTrue)
voltageEstimate = np.array(voltageEstimate)

# Plot SOC
plt.figure(figsize=(10,4))
plt.plot(t, socTrue, label='True SOC', linewidth=2)
plt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('SOC')
plt.title('SOC Estimator')
plt.grid(True)
plt.legend()
plt.show()

# Plot Voltage
plt.figure(figsize=(10,4))
plt.plot(t, voltageTrue, label='True Voltage', linewidth=2)
plt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('Voltage (V)')
plt.title('Voltage Estimator')
plt.grid(True)
plt.legend()
plt.show()

```

### Constant 2.2A Charge, 0% initial SOC
```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Q = 7920          # C
Rs = 0.05         # Ohm
kalmanGain = 0.0022
inputCurrent = 2.200  # A

# Initial states
socTrue = [0.00]
socEstimate = [0.50]

voltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]
voltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]

currentNoise = 0.01  # standard deviation of current noise
voltageNoise = 0.1   # standard deviation of voltage noise

timeStep = 0.1
timeEnd = 60*60*0.75
t = np.arange(0, timeEnd + timeStep, timeStep)

# Simulation loop
for i in range(1, len(t)):
    # True SOC update
    socDot = (1/Q) * inputCurrent
    socTrue.append(socTrue[i-1] + socDot*timeStep)
    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)

    # Estimated SOC update
    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())
                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()
                                    - voltageEstimate[i-1]))
    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)
    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))

# Convert to numpy arrays for plotting
socTrue = np.array(socTrue)
socEstimate = np.array(socEstimate)
voltageTrue = np.array(voltageTrue)
voltageEstimate = np.array(voltageEstimate)

# Plot SOC
plt.figure(figsize=(10,4))
plt.plot(t, socTrue, label='True SOC', linewidth=2)
plt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('SOC')
plt.title('SOC Estimator')
plt.grid(True)
plt.legend()
plt.show()

# Plot Voltage
plt.figure(figsize=(10,4))
plt.plot(t, voltageTrue, label='True Voltage', linewidth=2)
plt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('Voltage (V)')
plt.title('Voltage Estimator')
plt.grid(True)
plt.legend()
plt.show()

```
Despite noisy measurements, the SOC estimate converges smoothly to the true SOC. The voltage estimate tracks the real cell voltage closely, demonstrating effective observer feedback.

### Constant 0.5A Discharge, 90% initial SOC
```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt

# Parameters
Q = 7920          # C
Rs = 0.05         # Ohm
kalmanGain = 0.0022
inputCurrent = -2.200  # A

# Initial states
socTrue = [0.90]
socEstimate = [0.50]

voltageTrue = [2 + 2*socTrue[0] + Rs*inputCurrent]
voltageEstimate = [2 + 2*socEstimate[0] + Rs*inputCurrent]

currentNoise = 0.01  # standard deviation of current noise
voltageNoise = 0.1   # standard deviation of voltage noise

timeStep = 0.1
timeEnd = 60*60*0.75
t = np.arange(0, timeEnd + timeStep, timeStep)

# Simulation loop
for i in range(1, len(t)):
    # True SOC update
    socDot = (1/Q) * inputCurrent
    socTrue.append(socTrue[i-1] + socDot*timeStep)
    voltageTrue.append(2 + 2*socTrue[i] + Rs*inputCurrent)

    # Estimated SOC update
    socEstimateDot = ((1/Q)*(inputCurrent + currentNoise*np.random.randn())
                      + kalmanGain*(voltageTrue[i-1] + voltageNoise*np.random.randn()
                                    - voltageEstimate[i-1]))
    socEstimate.append(socEstimate[i-1] + socEstimateDot*timeStep)
    voltageEstimate.append(2 + 2*socEstimate[i] + Rs*(inputCurrent + currentNoise*np.random.randn()))

# Convert to numpy arrays for plotting
socTrue = np.array(socTrue)
socEstimate = np.array(socEstimate)
voltageTrue = np.array(voltageTrue)
voltageEstimate = np.array(voltageEstimate)

# Plot SOC
plt.figure(figsize=(10,4))
plt.plot(t, socTrue, label='True SOC', linewidth=2)
plt.plot(t, socEstimate, label='SOC Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('SOC')
plt.title('SOC Estimator')
plt.grid(True)
plt.legend()
plt.show()

# Plot Voltage
plt.figure(figsize=(10,4))
plt.plot(t, voltageTrue, label='True Voltage', linewidth=2)
plt.plot(t, voltageEstimate, label='Voltage Estimate', linewidth=2)
plt.xlabel('Time (s)')
plt.ylabel('Voltage (V)')
plt.title('Voltage Estimator')
plt.grid(True)
plt.legend()
plt.show()

```

At 500 seconds for 0.5 Amps discharge, the difference between the estimate and true SOC is about 4.7% percent. At 500 seconds for 2.2 Amps discharge and charge, the difference is about 4.4%. Thus from our model and observer we can conclude that after 500 seconds, the Kalman filter predicts the true SOC within 5% for standard operation, and continues to converge. But before 500 seconds, the error is drastically greater when the initial estimate is set at 50% charge. Depending on the application, it could make sense to adjust the initial estimate closer to 0% charge (to get a more accurate battery reading if it is close to empty). 


## Original Matlab Model
<details>
<summary>Show code</summary>



```matlab

clc; clf; clear;

Q = 7920; % C
Rs = 0.05; % Ohm
kalmanGain = 0.0022;
inputCurrent = -2.200; % A

socTrue = 0.90;
socEstimate = 0.50;

voltageTrue = 2 + 2*socTrue + Rs*inputCurrent;
voltageEstimate = 2 + 2*socEstimate + Rs*inputCurrent;

currentNoise = 0.01;
voltageNoise = 0.1;

timeStep = 0.1;
timeEnd = 60*60*0.75;
t = 0:timeStep:timeEnd;

for i = 2:length(t)
   socDot = (1/Q)*inputCurrent;
   socTrue(i) = socTrue(i-1) + socDot*timeStep;
   voltageTrue(i) = 2 + 2*socTrue(i) + Rs*inputCurrent;

   socEstimateDot = (1/Q)*(inputCurrent + currentNoise*randn()) ...
      + kalmanGain*(voltageTrue(i-1) + voltageNoise*randn() ...
      - voltageEstimate(i-1));

   socEstimate(i) = socEstimate(i-1) + socEstimateDot*timeStep;
   voltageEstimate(i) = 2 + 2*socEstimate(i) ...
      + Rs*(inputCurrent + currentNoise*randn());
end
```
</details>

[^1]: [Tenergy 18650 Li-ion Battery](https://power.tenergy.com/tenergy-li-ion-18650-cylindrical-3-6v-2200mah-flat-top-rechargeable-battery-ul-listed/)
[^2]: [Adafruit 18650 Li-ion Battery](https://www.adafruit.com/product/1781)